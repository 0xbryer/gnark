import (
	"crypto/subtle"
	"io"
)

// Bytes returns the binary representation of pk
// as x||y where x, y are the coordinates of the point
// on the twisted Edwards as big endian integers.
func (pk *PublicKey) Bytes() []byte {
	var res [sizePublicKey]byte
	x := pk.A.X.Bytes()
	y := pk.A.Y.Bytes()
	subtle.ConstantTimeCopy(1, res[:sizeFr], x[:])
	subtle.ConstantTimeCopy(1, res[sizeFr:], y[:])
	return res[:]
}

// SetBytes sets p from binary representation in buf.
// buf represents a public key as x||y where x, y are
// interpreted as big endian binary numbers corresponding
// to the coordinates of a point on the twisted Edwards.
// It returns the number of bytes read from the buffer.
func (pk *PublicKey) SetBytes(buf []byte) (int, error) {
	n := 0
	if len(buf) < sizePublicKey {
		return n, io.ErrShortBuffer
	}
	pk.A.X.SetBytes(buf[:sizeFr])
	pk.A.Y.SetBytes(buf[sizeFr : 2*sizeFr])
	n += 2 * sizeFr
	if !pk.A.IsOnCurve() {
		return n, errNotOnCurve
	}
	return n, nil
}

// Bytes returns the binary representation of pk,
// as byte array publicKey||scalar||randSrc
// where publicKey is as publicKey.Bytes(), and
// scalar is in big endian, of size sizeFr.
func (privKey *PrivateKey) Bytes() []byte {
	var res [sizePrivateKey]byte
	x := privKey.PublicKey.A.X.Bytes()
	y := privKey.PublicKey.A.Y.Bytes()
	subtle.ConstantTimeCopy(1, res[:sizeFr], x[:])
	subtle.ConstantTimeCopy(1, res[sizeFr:2*sizeFr], y[:])
	subtle.ConstantTimeCopy(1, res[2*sizeFr:3*sizeFr], privKey.scalar[:])
	subtle.ConstantTimeCopy(1, res[3*sizeFr:], privKey.randSrc[:])
	return res[:]
}

// SetBytes sets pk from buf, where buf is interpreted
// as  publicKey||scalar||randSrc
// where publicKey is as publicKey.Bytes(), and
// scalar is in big endian, of size sizeFr.
// It returns the number byte read.
func (privKey *PrivateKey) SetBytes(buf []byte) (int, error) {
	n := 0
	if len(buf) < sizePrivateKey {
		return n, io.ErrShortBuffer
	}
	privKey.PublicKey.A.X.SetBytes(buf[:sizeFr])
	privKey.PublicKey.A.Y.SetBytes(buf[sizeFr : 2*sizeFr])
	n += 2 * sizeFr
	if !privKey.PublicKey.A.IsOnCurve() {
		return n, errNotOnCurve
	}
	subtle.ConstantTimeCopy(1, privKey.scalar[:], buf[2*sizeFr:3*sizeFr])
	subtle.ConstantTimeCopy(1, privKey.randSrc[:], buf[3*sizeFr:])
	n += sizeFr
	return n, nil
}

// Bytes returns the binary representation of sig
// as a byte array of size 3*sizeFr x||y||s where
// * x, y are the coordinates of a point on the twisted
//	Edwards represented in big endian
// * s=r+h(r,a,m) mod l, the Hasse bound guarantess that
//	s is smaller than sizeFr (in particular it is supposed
// 	s is NOT blinded)
func (sig *Signature) Bytes() []byte {
	var res [sizeSignature]byte
	x := sig.R.X.Bytes()
	y := sig.R.Y.Bytes()
	subtle.ConstantTimeCopy(1, res[:sizeFr], x[:])
	subtle.ConstantTimeCopy(1, res[sizeFr:2*sizeFr], y[:])
	subtle.ConstantTimeCopy(1, res[2*sizeFr:], sig.S[:])
	return res[:]
}

// SetBytes sets sig from a buffer in binary.
// buf is read interpreted as x||y||s where
// * x,y are the coordinates of a point on the twisted
//	Edwards represented in big endian
// * s=r+h(r,a,m) mod l, the Hasse bound guarantess that
//	s is smaller than sizeFr (in particular it is supposed
// 	s is NOT blinded)
// It returns the number of bytes read from buf.
func (sig *Signature) SetBytes(buf []byte) (int, error) {
	n := 0
	if len(buf) < sizeSignature {
		return n, io.ErrShortBuffer
	}
	sig.R.X.SetBytes(buf[:sizeFr])
	sig.R.Y.SetBytes(buf[sizeFr : 2*sizeFr])
	n += 2 * sizeFr
	if !sig.R.IsOnCurve() {
		return n, errNotOnCurve
	}
	subtle.ConstantTimeCopy(1, sig.S[:], buf[2*sizeFr:3*sizeFr])
	n += sizeFr
	return n, nil
}