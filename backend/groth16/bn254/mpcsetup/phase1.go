// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package mpcsetup

import (
	"bytes"
	"crypto/sha256"
	"errors"
	"fmt"
	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"math"
	"math/big"
)

// Phase1 represents the Phase1 of the MPC described in
// https://eprint.iacr.org/2017/1050.pdf
//
// Also known as "Powers of Tau"
type Phase1 struct {
	Principal struct { // "main" contributions
		Tau, Alpha, Beta valueUpdate
	}
	G1Derived struct {
		Tau      []curve.G1Affine // {[τ⁰]₁, [τ¹]₁, [τ²]₁, …, [τ²ⁿ⁻²]₁}
		AlphaTau []curve.G1Affine // {α[τ⁰]₁, α[τ¹]₁, α[τ²]₁, …, α[τⁿ⁻¹]₁}
		BetaTau  []curve.G1Affine // {β[τ⁰]₁, β[τ¹]₁, β[τ²]₁, …, β[τⁿ⁻¹]₁}
	}
	G2Derived struct {
		Tau []curve.G2Affine // {[τ⁰]₂, [τ¹]₂, [τ²]₂, …, [τⁿ⁻¹]₂}
	}
	Challenge []byte // Hash of the transcript PRIOR to this participant
}

// Contribute contributes randomness to the Phase1 object. This mutates Phase1.
// p is trusted to be well-formed. The ReadFrom function performs such basic sanity checks.
func (p *Phase1) Contribute() {
	N := len(p.G2Derived.Tau)
	challenge := p.hash()

	// Generate main value updates
	var tau, alpha, beta *big.Int
	p.Principal.Tau, tau = updateValue(p.Principal.Tau.updatedCommitment, challenge, 1)
	p.Principal.Alpha, alpha = updateValue(p.Principal.Alpha.updatedCommitment, challenge, 2)
	p.Principal.Beta, beta = updateValue(p.Principal.Beta.updatedCommitment, challenge, 3)

	defer eraseBigInts(tau, alpha, beta)

	// Compute τ, ατ, and βτ
	taus := powers(tau, 2*N-1)
	alphaTau := make([]fr.Element, N)
	betaTau := make([]fr.Element, N)

	defer eraseFrVectors(taus, alphaTau, betaTau)

	alphaTau[0].SetBigInt(alpha)
	betaTau[0].SetBigInt(beta)
	for i := 1; i < N; i++ {
		alphaTau[i].Mul(&taus[i], &alphaTau[0])
		betaTau[i].Mul(&taus[i], &betaTau[0])
	}

	// Update using previous parameters
	// TODO @gbotrel working with jacobian points here will help with perf.
	scaleG1InPlace(p.G1Derived.Tau, taus)
	scaleG2InPlace(p.G2Derived.Tau, taus[0:N])
	scaleG1InPlace(p.G1Derived.AlphaTau, alphaTau)
	scaleG1InPlace(p.G1Derived.BetaTau, betaTau)

	p.Challenge = challenge
}

// NewPhase1 initialize phase 1 of the MPC. This is called once by the coordinator before
// any randomness contribution is made (see Contribute()).
func NewPhase1(power int) (phase1 Phase1) {
	N := int(math.Pow(2, float64(power)))

	_, _, g1, g2 := curve.Generators()

	phase1.Challenge = []byte{0}
	phase1.Principal.Alpha.setEmpty(true)
	phase1.Principal.Beta.setEmpty(true)
	phase1.Principal.Tau.setEmpty(false)

	phase1.G1Derived.Tau = make([]curve.G1Affine, 2*N-1)
	phase1.G2Derived.Tau = make([]curve.G2Affine, N)
	phase1.G1Derived.AlphaTau = make([]curve.G1Affine, N)
	phase1.G1Derived.BetaTau = make([]curve.G1Affine, N)
	for i := range phase1.G1Derived.Tau {
		phase1.G1Derived.Tau[i].Set(&g1)
	}
	for i := range phase1.G2Derived.Tau {
		phase1.G2Derived.Tau[i].Set(&g2)
		phase1.G1Derived.AlphaTau[i].Set(&g1)
		phase1.G1Derived.BetaTau[i].Set(&g1)
	}

	return
}

func VerifyPhase1(c0, c1 *Phase1, c ...*Phase1) error {
	contribs := append([]*Phase1{c0, c1}, c...)
	for i := 0; i < len(contribs)-1; i++ {
		if err := contribs[i].Verify(contribs[i+1]); err != nil {
			return err
		}
	}
	return nil
}

// Verify assumes previous is correct
func (p *Phase1) Verify(previous *Phase1) error {

	if prevHash := previous.hash(); !bytes.Equal(p.Challenge, previous.hash()) { // if chain-verifying contributions, challenge fields are optional as they can be computed as we go
		if len(p.Challenge) != 0 {
			return errors.New("the challenge does not match the previous phase's hash")
		}
		p.Challenge = prevHash
	}

	if err := p.Principal.Tau.verify(previous.Principal.Tau.updatedCommitment, p.Challenge, 1); err != nil {
		return fmt.Errorf("failed to verify contribution to τ: %w", err)
	}
	if err := p.Principal.Alpha.verify(previous.Principal.Alpha.updatedCommitment, p.Challenge, 2); err != nil {
		return fmt.Errorf("failed to verify contribution to α: %w", err)
	}
	if err := p.Principal.Beta.verify(previous.Principal.Beta.updatedCommitment, p.Challenge, 3); err != nil {
		return fmt.Errorf("failed to verify contribution to β: %w", err)
	}

	if !areInSubGroupG1(p.G1Derived.Tau) || !areInSubGroupG1(p.G1Derived.BetaTau) || !areInSubGroupG1(p.G1Derived.AlphaTau) {
		return errors.New("derived values 𝔾₁ subgroup check failed")
	}
	if !areInSubGroupG2(p.G2Derived.Tau) {
		return errors.New("derived values 𝔾₂ subgroup check failed")
	}

	_, _, g1, g2 := curve.Generators()

	// for 1 ≤ i ≤ 2N-3 we want to check τⁱ⁺¹/τⁱ = τ
	// i.e. e(τⁱ⁺¹,[1]₂) = e(τⁱ,[τ]₂). Due to bi-linearity we can instead check
	// e(∑rⁱ⁻¹τⁱ⁺¹,[1]₂) = e(∑rⁱ⁻¹τⁱ,[τ]₂), which is tantamount to the check
	// ∑rⁱ⁻¹τⁱ⁺¹ / ∑rⁱ⁻¹τⁱ = τ
	r := linearCombCoeffs(len(p.G1Derived.Tau) - 1) // the longest of all lengths
	// will be reusing the coefficient TODO @Tabaie make sure that's okay

	tauT1, tauS1 := linearCombinationsG1(r, p.G1Derived.Tau)
	tauT2, tauS2 := linearCombinationsG2(r, p.G2Derived.Tau)
	alphaTT, alphaTS := linearCombinationsG1(r, p.G1Derived.AlphaTau)
	betaTT, betaTS := linearCombinationsG1(r, p.G1Derived.BetaTau)

	if !sameRatioUnsafe(tauS1, tauT1, *p.Principal.Tau.updatedCommitment.g2, g2) {
		return errors.New("couldn't verify 𝔾₁ representations of the τⁱ")
	}

	if !sameRatioUnsafe(p.Principal.Tau.updatedCommitment.g1, g1, tauS2, tauT2) {
		return errors.New("couldn't verify 𝔾₂ representations of the τⁱ")
	}

	// for 0 ≤ i < N we want to check the ατⁱ
	// By well-formedness checked by ReadFrom, we assume that ατ⁰ = α
	// For 0 < i < N we check that ατⁱ/ατⁱ⁻¹ = τ, since we have a representation of τ in 𝔾₂
	// with a similar bi-linearity argument as above we can do this with a single pairing check

	if !sameRatioUnsafe(alphaTS, alphaTT, *p.Principal.Tau.updatedCommitment.g2, g2) {
		return errors.New("couldn't verify the ατⁱ")
	}
	if !sameRatioUnsafe(betaTS, betaTT, *p.Principal.Tau.updatedCommitment.g2, g2) {
		return errors.New("couldn't verify the βτⁱ")
	}

	return nil
}

func (p *Phase1) hash() []byte {
	if len(p.Challenge) == 0 {
		panic("challenge field missing")
	}
	sha := sha256.New()
	p.writeTo(sha)
	return sha.Sum(nil)
}
