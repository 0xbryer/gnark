// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package mpcsetup

import (
	"bytes"
	"crypto/rand"
	"errors"
	"math/big"
	"math/bits"
	"runtime"
	"time"

	"github.com/consensys/gnark-crypto/ecc"
	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark/internal/utils"
)

type PublicKey struct {
	SG  curve.G1Affine
	SXG curve.G1Affine
	XR  curve.G2Affine // XR = X.R ‚àà ùîæ‚ÇÇ proof of knowledge
}

func newPublicKey(x fr.Element, challenge []byte, dst byte) PublicKey {
	var pk PublicKey
	_, _, g1, _ := curve.Generators()

	var s fr.Element
	var sBi big.Int
	s.SetRandom()
	s.BigInt(&sBi)
	pk.SG.ScalarMultiplication(&g1, &sBi)

	// compute x*sG1
	var xBi big.Int
	x.BigInt(&xBi)
	pk.SXG.ScalarMultiplication(&pk.SG, &xBi)

	// generate R based on sG1, sxG1, challenge, and domain separation tag (tau, alpha or beta)
	R := genR(pk.SG, pk.SXG, challenge, dst)

	// compute x*spG2
	pk.XR.ScalarMultiplication(&R, &xBi)
	return pk
}

func bitReverse[T any](a []T) {
	n := uint64(len(a))
	nn := uint64(64 - bits.TrailingZeros64(n))

	for i := uint64(0); i < n; i++ {
		irev := bits.Reverse64(i) >> nn
		if irev > i {
			a[i], a[irev] = a[irev], a[i]
		}
	}
}

func linearCombCoeffs(n int) []fr.Element {
	a, err := rand.Int(rand.Reader, fr.Modulus())
	if err != nil {
		panic(err)
	}
	return powers(a, n)
}

// Returns [1, a, a¬≤, ..., a‚Åø‚Åª¬π ]
func powers(a *big.Int, n int) []fr.Element {
	var aMont fr.Element
	aMont.SetBigInt(a)
	result := make([]fr.Element, n)
	result[0] = fr.NewElement(1)
	for i := 1; i < n; i++ {
		result[i].Mul(&result[i-1], &aMont)
	}
	return result
}

// Returns [a·µ¢A·µ¢, ...]‚ààùîæ‚ÇÅ
func scaleG1InPlace(A []curve.G1Affine, a []fr.Element) {
	utils.Parallelize(len(A), func(start, end int) {
		var tmp big.Int
		for i := start; i < end; i++ {
			a[i].BigInt(&tmp)
			A[i].ScalarMultiplication(&A[i], &tmp)
		}
	})
}

// Returns [a·µ¢A·µ¢, ...]‚ààùîæ‚ÇÇ
func scaleG2InPlace(A []curve.G2Affine, a []fr.Element) {
	utils.Parallelize(len(A), func(start, end int) {
		var tmp big.Int
		for i := start; i < end; i++ {
			a[i].BigInt(&tmp)
			A[i].ScalarMultiplication(&A[i], &tmp)
		}
	})
}

/*
// Check e(a‚ÇÅ, a‚ÇÇ) = e(b‚ÇÅ, b‚ÇÇ)
func sameRatio(a1, b1 curve.G1Affine, a2, b2 curve.G2Affine) bool {
	if !a1.IsInSubGroup() || !b1.IsInSubGroup() || !a2.IsInSubGroup() || !b2.IsInSubGroup() {
		panic("invalid point not in subgroup")
	}
	return sameRatioUnsafe(a1, b1, a2, b2)
}*/

// Check n‚ÇÅ/d‚ÇÅ = n‚ÇÇ/d‚ÇÇ i.e. e(n‚ÇÅ, d‚ÇÇ) = e(d‚ÇÅ, n‚ÇÇ). No subgroup checks.
func sameRatioUnsafe(n1, d1 curve.G1Affine, n2, d2 curve.G2Affine) bool {
	var nd1 curve.G1Affine
	nd1.Neg(&d1)
	res, err := curve.PairingCheck(
		[]curve.G1Affine{n1, nd1},
		[]curve.G2Affine{d2, n2})
	if err != nil {
		panic(err)
	}
	return res
}

// returns a = ‚àë r·µ¢A·µ¢, b = ‚àë r·µ¢B·µ¢
func merge(A, B []curve.G1Affine) (a, b curve.G1Affine) {
	nc := runtime.NumCPU()
	r := make([]fr.Element, len(A))
	for i := 0; i < len(A); i++ {
		r[i].SetRandom()
	}
	a.MultiExp(A, r, ecc.MultiExpConfig{NbTasks: nc / 2})
	b.MultiExp(B, r, ecc.MultiExpConfig{NbTasks: nc / 2})
	return
}

// truncated = ‚àë r·µ¢A·µ¢, shifted = ‚àë r·µ¢A·µ¢‚Çä‚ÇÅ‚ààùîæ‚ÇÅ
func linearCombinationG1(r []fr.Element, A []curve.G1Affine, nbTasks int) curve.G1Affine {
	n := len(A)
	r = r[:n-1]
	var res curve.G1Affine
	res.MultiExp(A[:n-1], r, ecc.MultiExpConfig{NbTasks: nc / 2})
	shifted.MultiExp(A[1:], r, ecc.MultiExpConfig{NbTasks: nc / 2})
	return
}

// truncated = ‚àë r·µ¢A·µ¢, shifted = ‚àë r·µ¢A·µ¢‚Çä‚ÇÅ‚ààùîæ‚ÇÇ
func linearCombinationG2(r []fr.Element, A []curve.G2Affine) (truncated, shifted curve.G2Affine) {
	nc := runtime.NumCPU()
	n := len(A)
	r = r[:n-1]
	truncated.MultiExp(A[:n-1], r, ecc.MultiExpConfig{NbTasks: nc / 2})
	shifted.MultiExp(A[1:], r, ecc.MultiExpConfig{NbTasks: nc / 2})
	return
}

// linearCombinationsG1 assumes, and does not check, that rPowers[i+1] = rPowers[1].rPowers[i] for all applicable i
// Also assumed that 3 ‚â§ N ‚âî len(A) ‚â§ len(rPowers)
func linearCombinationsG1(rPowers []fr.Element, A []curve.G1Affine) (truncated, shifted curve.G1Affine) {
	// the common section, 1 to N-2
	var common curve.G1Affine
	common.MultiExp(A[1:len(A)-1], rPowers[:len(A)-2], ecc.MultiExpConfig{NbTasks: runtime.NumCPU()}) // A[1] + r.A[2] + ... + r·¥∫‚Åª¬≥.A[N-2]

	var c big.Int
	rPowers[1].BigInt(&c)
	truncated.ScalarMultiplication(&common, &c).Add(&truncated, &A[0]) // A[0] + r.A[1] + r¬≤.A[2] + ... + r·¥∫‚Åª¬≤.A[N-2]

	rPowers[len(A)-1].BigInt(&c)
	shifted.ScalarMultiplication(&A[len(A)-1], &c).Add(&shifted, &common)

	return
}

// linearCombinationsG2 assumes, and does not check, that rPowers[i+1] = rPowers[1].rPowers[i] for all applicable i
// Also assumed that 3 ‚â§ N ‚âî len(A) ‚â§ len(rPowers)
func linearCombinationsG2(rPowers []fr.Element, A []curve.G2Affine) (truncated, shifted curve.G2Affine) {
	// the common section, 1 to N-2
	var common curve.G2Affine
	common.MultiExp(A[1:len(A)-1], rPowers[:len(A)-2], ecc.MultiExpConfig{NbTasks: runtime.NumCPU()}) // A[1] + r.A[2] + ... + r·¥∫‚Åª¬≥.A[N-2]

	var c big.Int
	rPowers[1].BigInt(&c)
	truncated.ScalarMultiplication(&common, &c).Add(&truncated, &A[0]) // A[0] + r.A[1] + r¬≤.A[2] + ... + r·¥∫‚Åª¬≤.A[N-2]

	rPowers[len(A)-1].BigInt(&c)
	shifted.ScalarMultiplication(&A[len(A)-1], &c).Add(&shifted, &common)

	return
}

// Generate R‚ààùîæ‚ÇÇ as Hash(gÀ¢, gÀ¢À£, challenge, dst)
// it is to be used as a challenge for generating a proof of knowledge to x
// œÄ ‚âî x.r; e([1]‚ÇÅ, œÄ) =Ôπñ e([x]‚ÇÅ, r)
func genR(sG1, sxG1 curve.G1Affine, challenge []byte, dst byte) curve.G2Affine {
	var buf bytes.Buffer
	buf.Grow(len(challenge) + curve.SizeOfG1AffineUncompressed*2)
	buf.Write(sG1.Marshal())
	buf.Write(sxG1.Marshal())
	buf.Write(challenge)
	spG2, err := curve.HashToG2(buf.Bytes(), []byte{dst})
	if err != nil {
		panic(err)
	}
	return spG2
}

type RandomBeacon func(time.Time) []byte

// func (rb RandomBeacon) GenerateChallenge(...) []byte {}

type pair struct {
	g1 curve.G1Affine
	g2 *curve.G2Affine // optional; some values expect to have a ùîæ‚ÇÇ representation, some don't.
}

// check that g1, g2 are valid as updated values, i.e. in their subgroups, and non-zero
func (p *pair) validUpdate() bool {
	// if the contribution is 0 the product is doomed to be 0.
	// no need to check this for g2 independently because if g1 is 0 and g2 is not, consistency checks will fail
	return !p.g1.IsInfinity() && p.g1.IsInSubGroup() && (p.g2 == nil || p.g2.IsInSubGroup())
}

type valueUpdate struct {
	contributionCommitment curve.G1Affine // x or [X‚±º]‚ÇÅ
	contributionPok        curve.G2Affine // œÄ ‚âî x.r ‚àà ùîæ‚ÇÇ
	updatedCommitment      pair           // [X‚ÇÅ..X‚±º]
}

// updateValue produces values associated with contribution to an existing value.
// if prevCommitment contains only a ùîæ‚ÇÅ value, then so will updatedCommitment
// the second output is toxic waste. It is the caller's responsibility to safely "dispose" of it.
func updateValue(prevCommitment pair, challenge []byte, dst byte) (valueUpdate, *big.Int) {
	var x valueUpdate
	contributionValue, err := rand.Int(rand.Reader, fr.Modulus())

	if err != nil {
		panic(err)
	}

	_, _, g1, _ := curve.Generators()
	x.contributionCommitment.ScalarMultiplication(&g1, contributionValue)
	x.updatedCommitment.g1.ScalarMultiplication(&prevCommitment.g1, contributionValue)
	if prevCommitment.g2 != nil { // TODO make sure this is correct
		x.updatedCommitment.g2 = new(curve.G2Affine).ScalarMultiplication(prevCommitment.g2, contributionValue)
	}

	// proof of knowledge to commitment. Algorithm 3 from section 3.7
	pokBase := genR(x.contributionCommitment, x.updatedCommitment.g1, challenge, dst) // r
	x.contributionPok.ScalarMultiplication(&pokBase, contributionValue)

	return x, contributionValue
}

// verify corresponds with verification steps {i, i+3} with 1 ‚â§ i ‚â§ 3 in section 7.1 of Bowe-Gabizon17
// it checks the proof of knowledge of the contribution, and the fact that the product of the contribution
// and previous commitment makes the new commitment.
// prevCommitment is assumed to be valid. No subgroup check and the like.
func (x *valueUpdate) verify(prevCommitment pair, challenge []byte, dst byte) error {
	noG2 := prevCommitment.g2 == nil
	if noG2 != (x.updatedCommitment.g2 == nil) {
		return errors.New("erasing or creating g2 values")
	}

	if !x.contributionPok.IsInSubGroup() || !x.contributionCommitment.IsInSubGroup() || !x.updatedCommitment.validUpdate() {
		return errors.New("contribution values subgroup check failed")
	}

	// verify commitment proof of knowledge. CheckPOK, algorithm 4 from section 3.7
	r := genR(x.contributionCommitment, x.updatedCommitment.g1, challenge, dst) // verification challenge in the form of a g2 base
	_, _, g1, _ := curve.Generators()
	if !sameRatioUnsafe(x.contributionCommitment, g1, x.contributionPok, r) { // œÄ =? x.r i.e. x/g1 =? œÄ/r
		return errors.New("contribution proof of knowledge verification failed")
	}

	// check that the updated/previous ratio is consistent between the ùîæ‚ÇÅ and ùîæ‚ÇÇ representations. Based on CONSISTENT, algorithm 2 in Section 3.6.
	if !noG2 && !sameRatioUnsafe(x.updatedCommitment.g1, prevCommitment.g1, *x.updatedCommitment.g2, *prevCommitment.g2) {
		return errors.New("g2 update inconsistent")
	}

	// now verify that updated‚ÇÅ/previous‚ÇÅ = x ( = x/g1 = œÄ/r )
	// have to use the latter value for the RHS because we sameRatio needs both ùîæ‚ÇÅ and ùîæ‚ÇÇ values
	if !sameRatioUnsafe(x.updatedCommitment.g1, prevCommitment.g1, x.contributionPok, r) {
		return errors.New("g1 update inconsistent")
	}

	return nil
}

// setEmpty does not provide proofs, only sets the value to [1]
func (x *valueUpdate) setEmpty(g1Only bool) {
	_, _, g1, g2 := curve.Generators()
	x.updatedCommitment.g1.Set(&g1)
	if !g1Only {
		x.updatedCommitment.g2 = &g2
	}
}

func toRefs[T any](s []T) []*T {
	res := make([]*T, len(s))
	for i := range s {
		res[i] = &s[i]
	}
	return res
}

func areInSubGroup[T interface{ IsInSubGroup() bool }](s []T) bool {
	for i := range s {
		if !s[i].IsInSubGroup() {
			return false
		}
	}
	return true
}

func areInSubGroupG1(s []curve.G1Affine) bool {
	return areInSubGroup(toRefs(s))
}

func areInSubGroupG2(s []curve.G2Affine) bool {
	return areInSubGroup(toRefs(s))
}

func truncate[T any](s []T) []T {
	return s[:len(s)-1]
}

func eraseBigInts(i ...*big.Int) {
	for _, i := range i {
		if i != nil {
			for j := range i.Bits() {
				i.Bits()[j] = 0
			}
		}
	}
}

func eraseFrVectors(v ...[]fr.Element) {
	for _, v := range v {
		for i := range v {
			v[i].SetZero()
		}
	}
}
