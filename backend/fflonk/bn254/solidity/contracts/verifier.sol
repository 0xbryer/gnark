// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

pragma solidity ^0.8.19;

contract PlonkVerifier {

  uint256 private constant R_MOD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
  uint256 private constant R_MOD_MINUS_ONE = 21888242871839275222246405745257275088548364400416034343698204186575808495616;
  uint256 private constant P_MOD = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
  uint256 private constant G2_SRS_0_X_0 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
  uint256 private constant G2_SRS_0_X_1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
  uint256 private constant G2_SRS_0_Y_0 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
  uint256 private constant G2_SRS_0_Y_1 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
  
  uint256 private constant G2_SRS_1_X_0 = 2443430939986969712743682923434644543094899517010817087050769422599268135103;
  uint256 private constant G2_SRS_1_X_1 = 14502447760486387799059318541209757040844770937862468921929310682431317530875;
  uint256 private constant G2_SRS_1_Y_0 = 4704672529862198727079301732358554332963871698433558481208245291096060730807;
  uint256 private constant G2_SRS_1_Y_1 = 11721331165636005533649329538372312212753336165656329339895621434122061690013;
  uint256 private constant G1_SRS_X = 1;
  uint256 private constant G1_SRS_Y = 2;

  // ----------------------- vk ---------------------
  uint256 private constant VK_DOMAIN_SIZE = 16;
  uint256 private constant VK_INV_DOMAIN_SIZE = 20520227692349320520856005386178695395514091625390032197217066424914820464641;
  uint256 private constant VK_OMEGA = 14940766826517323942636479241147756311199852622225275649687664389641784935947;
  uint256 private constant VK_NB_PUBLIC_INPUTS = 1;
  uint256 private constant VK_COSET_SHIFT = 5;
  uint256 private constant VK_QPUBLIC_COM_X = 17443873348629404854512717542222672836727832681524810124661542853709261714171;
  uint256 private constant VK_QPUBLIC_COM_Y = 16230738686584538149177705638663046415086069376976404115028486550000826831885;uint256 private constant VK_INDEX_COMMIT_API_0 = 7;
  uint256 private constant VK_NB_CUSTOM_GATES = 1;

  // --------------------------- proof -----------------

  uint256 private constant PROOF_LROENTANGLED_COM_X = 0x00;
  uint256 private constant PROOF_LROENTANGLED_COM_Y = 0x20;
  uint256 private constant PROOF_Z_X = 0x40;
  uint256 private constant PROOF_Z_Y = 0x60;
  uint256 private constant PROOF_Z_ENTANGLED_X = 0x80;
  uint256 private constant PROOF_Z_ENTANGLED_Y = 0xa0;
  uint256 private constant PROOF_H_ENTANGLED_X = 0xc0;
  uint256 private constant PROOF_H_ENTANGLED_Y = 0xe0;
  uint256 private constant PROOF_BSB_0_X = 0x100;
  uint256 private constant PROOF_BSB_0_Y = 0x120;
  
  uint256 private constant PROOF_QL_AT_ZETA = 0x160;
  uint256 private constant PROOF_QR_AT_ZETA = 0x180;
  uint256 private constant PROOF_QM_AT_ZETA = 0x1a0;
  uint256 private constant PROOF_QO_AT_ZETA = 0x1c0;
  uint256 private constant PROOF_QKINCOMPLETE_AT_ZETA = 0x1e0;
  uint256 private constant PROOF_S1_AT_ZETA = 0x200;
  uint256 private constant PROOF_S2_AT_ZETA = 0x220;
  uint256 private constant PROOF_S3_AT_ZETA = 0x240;
  uint256 private constant PROOF_QCP_0_AT_ZETA = 0x260;
  uint256 private constant PROOF_L_AT_ZETA = 0x280;
  uint256 private constant PROOF_R_AT_ZETA = 0x2a0;
  uint256 private constant PROOF_O_AT_ZETA = 0x2c0;
  uint256 private constant PROOF_Z_AT_ZETA = 0x2e0;
  uint256 private constant PROOF_H1_AT_ZETA = 0x300;
  uint256 private constant PROOF_H2_AT_ZETA = 0x320;
  uint256 private constant PROOF_H3_AT_ZETA = 0x340;
  uint256 private constant PROOF_BSB_0_AT_ZETA = 0x360;
  uint256 private constant PROOF_Z_AT_ZETA_OMEGA = 0x380;
  uint256 private constant PROOF_SHPLONK_W_X = 0x3a0;
  uint256 private constant PROOF_SHPLONK_W_Y = 0x3c0;
  uint256 private constant PROOF_SHPLONK_W_PRIME_X = 0x3e0;
  uint256 private constant PROOF_SHPLONK_W_PRIME_Y = 0x400;

  uint256 private constant PROOF_SHPLONK_P0_0 = 0x420;
  uint256 private constant PROOF_SHPLONK_P0_1 = 0x440;
  uint256 private constant PROOF_SHPLONK_P0_2 = 0x460;
  uint256 private constant PROOF_SHPLONK_P0_3 = 0x480;
  uint256 private constant PROOF_SHPLONK_P0_4 = 0x4a0;
  uint256 private constant PROOF_SHPLONK_P0_5 = 0x4c0;
  uint256 private constant PROOF_SHPLONK_P0_6 = 0x4e0;
  uint256 private constant PROOF_SHPLONK_P0_7 = 0x500;
  uint256 private constant PROOF_SHPLONK_P0_8 = 0x520;
  uint256 private constant PROOF_SHPLONK_P0_9 = 0x540;
  uint256 private constant PROOF_SHPLONK_P0_10 = 0x560;
  uint256 private constant PROOF_SHPLONK_P0_11 = 0x580;
  uint256 private constant PROOF_SHPLONK_P0_12 = 0x5a0;
  uint256 private constant PROOF_SHPLONK_P0_13 = 0x5c0;
  uint256 private constant PROOF_SHPLONK_P0_14 = 0x5e0;
  uint256 private constant PROOF_SHPLONK_P0_15 = 0x600;
  uint256 private constant PROOF_SHPLONK_P0_16 = 0x620;
  uint256 private constant PROOF_SHPLONK_P0_17 = 0x640;
  uint256 private constant PROOF_SHPLONK_P1_0 = 0x660;

  // -------- offset state
  
  uint256 private constant STATE_ALPHA = 0x0;
  uint256 private constant STATE_BETA = 0x20;
  uint256 private constant STATE_GAMMA = 0x40;
  uint256 private constant STATE_ZETA = 0x60;
  uint256 private constant STATE_ALPHA_SQUARE_LAGRANGE_0 = 0x80;
  uint256 private constant STATE_SUCCESS = 0xa0;
  uint256 private constant STATE_CHECK_VAR = 0xc0;
  uint256 private constant STATE_LAST_MEM = 0xe0;

  // -------- errors
  uint256 private constant ERROR_STRING_ID = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)

  // -------- precompiles
  uint256 private constant SHA_256 = 0x2;

  event PrintUint256(uint256 x);

  /// Verify a Plonk proof.
  /// Reverts if the proof or the public inputs are malformed.
  /// @param proof serialised plonk proof (using gnark's MarshalSolidity)
  /// @param public_inputs (must be reduced)
  /// @return success true if the proof passes false otherwise
  function Verify(bytes calldata proof, uint256[] calldata public_inputs) 
  public returns(bool success) {

    uint256 check;

	assembly {

		// state memory and scratch memory
		let mem := mload(0x40)
		let freeMem := add(mem, STATE_LAST_MEM)

		// compute the challenges
		let prev_challenge_non_reduced
		prev_challenge_non_reduced := derive_gamma(proof.offset, public_inputs.length, public_inputs.offset)
		prev_challenge_non_reduced := derive_beta(prev_challenge_non_reduced)
		prev_challenge_non_reduced := derive_alpha(proof.offset, prev_challenge_non_reduced)
    check := mload(add(mem, STATE_ALPHA))
		// derive_zeta(proof.offset, prev_challenge_non_reduced)

		// Beginning errors -------------------------------------------------

      function error_nb_public_inputs() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x1d)
        mstore(add(ptError, 0x44), "wrong number of public inputs")
        revert(ptError, 0x64)
      }

      /// Called when an operation on Bn254 fails
      /// @dev for instance when calling EcMul on a point not on Bn254.
      function error_ec_op() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x12)
        mstore(add(ptError, 0x44), "error ec operation")
        revert(ptError, 0x64)
      }

      /// Called when one of the public inputs is not reduced.
      function error_inputs_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x18)
        mstore(add(ptError, 0x44), "inputs are bigger than r")
        revert(ptError, 0x64)
      }

      /// Called when the size proof is not as expected
      /// @dev to avoid overflow attack for instance
      function error_proof_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x10)
        mstore(add(ptError, 0x44), "wrong proof size")
        revert(ptError, 0x64)
      }

      /// Called when one the openings is bigger than r
      /// The openings are the claimed evalutions of a polynomial
      /// in a Kzg proof.
      function error_proof_openings_size() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x16)
        mstore(add(ptError, 0x44), "openings bigger than r")
        revert(ptError, 0x64)
      }

      function error_verify() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0xc)
        mstore(add(ptError, 0x44), "error verify")
        revert(ptError, 0x64)
      }

      function error_random_generation() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x14)
        mstore(add(ptError, 0x44), "error random gen kzg")
        revert(ptError, 0x64)
      }
      // end errors -------------------------------------------------

		// Beginning challenges -------------------------------------------------

		/// Derive gamma as Sha256(<transcript>)
		/// @param aproof pointer to the proof
		/// @param nb_pi number of public inputs
		/// @param pi pointer to the array of public inputs
		/// @return the challenge gamma, not reduced
		/// @notice The transcript is the concatenation (in this order) of:
		/// * the word "gamma" in ascii, equal to [0x67,0x61,0x6d, 0x6d, 0x61] and encoded as a uint256.
		/// * the entangled commitments to ql,qr,qm,qo,qkIncomplete,s1,s2,s3,qcp_i
		/// * the entangled commitment to l, r, o
		/// The data described above is written starting at mPtr. "gamma" lies on 5 bytes,
		/// and is encoded as a uint256 number n. In basis b = 256, the number looks like this
		/// [0 0 0 .. 0x67 0x61 0x6d, 0x6d, 0x61]. The first non zero entry is at position 27=0x1b
		/// Gamma reduced (the actual challenge) is stored at add(state, state_gamma)
		function derive_gamma(aproof, nb_pi, pi)->gamma_not_reduced {
			let state := mload(0x40)
			let mPtr := add(state, STATE_LAST_MEM)
			mstore(mPtr, 0x67616d6d61) // "gamma" in ascii is [0x67,0x61,0x6d, 0x6d, 0x61]
			mstore(add(mPtr, 0x20), VK_QPUBLIC_COM_X)
			mstore(add(mPtr, 0x40), VK_QPUBLIC_COM_Y)
			let _mPtr := add(mPtr, 0x60)
			let size_pi_in_bytes := mul(nb_pi, 0x20)
			calldatacopy(_mPtr, pi, size_pi_in_bytes)
			_mPtr := add(_mPtr, size_pi_in_bytes)
			calldatacopy(_mPtr, add(aproof, PROOF_LROENTANGLED_COM_X), 0x40)
			let size := add(0x85, size_pi_in_bytes)
			
			let l_success := staticcall(gas(), SHA_256, add(mPtr, 0x1b), size, mPtr, 0x20) //0x1b -> 000.."gamma"
			if iszero(l_success) {
			error_verify()
			}
			gamma_not_reduced := mload(mPtr)
			mstore(add(state, STATE_GAMMA), mod(gamma_not_reduced, R_MOD))
		}

		/// derive beta as Sha256<transcript>
		/// @param gamma_not_reduced the previous challenge (gamma) not reduced
		/// @return beta_not_reduced the next challenge, beta, not reduced
		/// @notice the transcript consists of the previous challenge only.
		/// The reduced version of beta is stored at add(state, state_beta)
		function derive_beta(gamma_not_reduced)->beta_not_reduced{
      let state := mload(0x40)
			let mPtr := add(mload(0x40), STATE_LAST_MEM)
			mstore(mPtr, 0x62657461) // "beta" in ascii is [0x62,0x65,0x74,0x61]
			mstore(add(mPtr, 0x20), gamma_not_reduced)
			let l_success := staticcall(gas(), SHA_256, add(mPtr, 0x1c), 0x24, mPtr, 0x20) //0x1b -> 000.."gamma"
			if iszero(l_success) {
			error_verify()
			}
			beta_not_reduced := mload(mPtr)
			mstore(add(state, STATE_BETA), mod(beta_not_reduced, R_MOD))
		}

		/// derive alpha as sha256<transcript>
		/// @param aproof pointer to the proof object
		/// @param beta_not_reduced the previous challenge (beta) not reduced
		/// @return alpha_not_reduced the next challenge, alpha, not reduced
		/// @notice the transcript consists of the previous challenge (beta)
		/// not reduced, the commitments to the wires associated to the QCP_i,
		/// and the commitment to the grand product polynomial 
		function derive_alpha(aproof, beta_not_reduced)->alpha_not_reduced {
			let state := mload(0x40)
			let mPtr := add(mload(0x40), STATE_LAST_MEM)
			mstore(mPtr, 0x616C706861) // "alpha" in ascii is [0x61,0x6C,0x70,0x68,0x61]
			let _mPtr := add(mPtr, 0x20)
			mstore(_mPtr, beta_not_reduced)
			_mPtr := add(_mPtr, 0x20)
			let size_bsb_commitments := mul(0x40, VK_NB_CUSTOM_GATES)
			calldatacopy(_mPtr, add(aproof, PROOF_BSB_0_X), size_bsb_commitments)
			_mPtr := add(_mPtr, size_bsb_commitments)
			calldatacopy(_mPtr, add(aproof, PROOF_Z_ENTANGLED_X), 0x40)
      let size := add(0x65, size_bsb_commitments)
			let l_success := staticcall(gas(), SHA_256, add(mPtr, 0x1b), size, mPtr, 0x20)
			if iszero(l_success) {
			error_verify()
			}

			alpha_not_reduced := mload(mPtr)
			mstore(add(state, STATE_ALPHA), mod(alpha_not_reduced, R_MOD))
		}

		/// derive zeta as sha256<transcript>
		/// @param aproof pointer to the proof object
		/// @param alpha_not_reduced the previous challenge (alpha) not reduced
		/// The transcript consists of the previous challenge and the commitment to
		/// the quotient polynomial h.
		// function derive_zeta(aproof, alpha_not_reduced) {
			
		// 	let state := mload(0x40)
		// 	let mPtr := add(mload(0x40), STATE_LAST_MEM)

		// 	// zeta
		// 	mstore(mPtr, 0x7a657461) // "zeta"
		// 	mstore(add(mPtr, 0x20), alpha_not_reduced)
		// 	calldatacopy(add(mPtr, 0x40), add(aproof, PROOF_H_0_X), 0xc0)
		// 	let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1c), 0xe4, mPtr, 0x20)
		// 	if iszero(l_success) {
		// 	error_verify()
		// 	}
		// 	let zeta_not_reduced := mload(mPtr)
		// 	mstore(add(state, STATE_ZETA), mod(zeta_not_reduced, R_MOD))
		// }
		// END challenges -------------------------------------------------

	}
  emit PrintUint256(check);
	return true;

  }
}
