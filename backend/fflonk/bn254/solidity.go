package fflonk

const tmplSolidityVerifier = `// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

pragma solidity ^0.8.19;

contract PlonkVerifier {

  uint256 private constant R_MOD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
  uint256 private constant R_MOD_MINUS_ONE = 21888242871839275222246405745257275088548364400416034343698204186575808495616;
  uint256 private constant P_MOD = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
  {{- range $index, $element := .Kzg.G2 }}
  uint256 private constant G2_SRS_{{ $index }}_X_0 = {{ (fpstr $element.X.A1) }};
  uint256 private constant G2_SRS_{{ $index }}_X_1 = {{ (fpstr $element.X.A0) }};
  uint256 private constant G2_SRS_{{ $index }}_Y_0 = {{ (fpstr $element.Y.A1) }};
  uint256 private constant G2_SRS_{{ $index }}_Y_1 = {{ (fpstr $element.Y.A0) }};
  {{ end -}}
  uint256 private constant G1_SRS_X = {{ fpstr .Kzg.G1.X }};
  uint256 private constant G1_SRS_Y = {{ fpstr .Kzg.G1.Y }};

  // ----------------------- vk ---------------------
  uint256 private constant VK_DOMAIN_SIZE = {{ .Size }};
  uint256 private constant VK_INV_DOMAIN_SIZE = {{ (frstr .SizeInv) }};
  uint256 private constant VK_OMEGA = {{ (frstr .Generator) }};
  uint256 private constant VK_NB_PUBLIC_INPUTS = {{ .NbPublicVariables }};
  uint256 private constant VK_COSET_SHIFT = 5;
  uint256 private constant VK_QPUBLIC_COM_X = {{ (fpstr .Qpublic.X) }};
  uint256 private constant VK_QPUBLIC_COM_Y = {{ (fpstr .Qpublic.Y) }};
  {{- range $index, $element := .CommitmentConstraintIndexes -}}
  uint256 private constant VK_INDEX_COMMIT_API_{{ $index }} = {{ $element }};
  {{ end -}}
  uint256 private constant VK_NB_CUSTOM_GATES = {{ len .CommitmentConstraintIndexes }};

  // --------------------------- proof -----------------

  uint256 private constant PROOF_LROENTANGLED_COM_X = 0x00;
  uint256 private constant PROOF_LROENTANGLED_COM_Y = 0x20;
  uint256 private constant PROOF_Z_X = 0x40;
  uint256 private constant PROOF_Z_Y = 0x60;
  uint256 private constant PROOF_Z_ENTANGLED_X = 0x80;
  uint256 private constant PROOF_Z_ENTANGLED_Y = 0xa0;
  uint256 private constant PROOF_H_ENTANGLED = 0xc0;
  uint256 private constant PROOF_H_ENTANGLED = 0xe0;
  {{- range $index, $element := .CommitmentConstraintIndexes}}
  uint256 private constant PROOF_BSB_{{ $index }}_X = {{ hex ( add 0x100 (mul 0x20 $index) ) }};
  uint256 private constant PROOF_BSB_{{ $index }}_Y = {{ hex ( add 0x120 (mul 0x20 $index) ) }};
  {{ end -}}{{ $offset := add 0x140 (mul 0x20 (len .CommitmentConstraintIndexes )) }}
  uint256 private constant PROOF_QL_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_QR_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_QM_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_QO_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_QKINCOMPLETE_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_S1_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_S2_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_S3_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  {{- range $index, $element := .CommitmentConstraintIndexes}}
  uint256 private constant PROOF_QCP_{{ $index }}_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  {{ end -}}
  uint256 private constant PROOF_L_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_R_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_O_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_Z_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_H1_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_H2_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_H3_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  {{- range $index, $element := .CommitmentConstraintIndexes}}
  uint256 private constant PROOF_BSB_{{ $index }}_AT_ZETA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  {{ end -}}
  uint256 private constant PROOF_Z_AT_ZETA_OMEGA = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_W_X = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_W_X = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_W_PRIME_X = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_W_PRIME_Y = {{ hex $offset }};{{ $offset = add $offset 0x20}}

  uint256 private constant PROOF_SHPLONK_P0_0 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_1 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_2 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_3 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_4 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_5 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_6 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_7 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_8 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_9 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_10 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_11 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_12 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_13 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_14 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_15 = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  {{- range $index, $element := .CommitmentConstraintIndexes }}
  uint256 private constant PROOF_SHPLONK_P0_{{ add 15 (mul 2 $index)}} = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  uint256 private constant PROOF_SHPLONK_P0_{{ add 16 (mul 2 $index)}} = {{ hex $offset }};{{ $offset = add $offset 0x20}}
  {{ end -}}
  uint256 private constant PROOF_SHPLONK_P1_0 = {{ hex $offset }};{{ $offset = add $offset 0x20}}

  /// Verify a Plonk proof.
  /// Reverts if the proof or the public inputs are malformed.
  /// @param proof serialised plonk proof (using gnark's MarshalSolidity)
  /// @param public_inputs (must be reduced)
  /// @return success true if the proof passes false otherwise
  function Verify(bytes calldata proof, uint256[] calldata public_inputs) 
  public view returns(bool success) {

	return true;

  }
}
`

// MarshalSolidity convert  s a proof to a byte array that can be used in a
// Solidity contract.
func (proof *Proof) MarshalSolidity() []byte {

	res := make([]byte, 0, 1024)

	// uint256 lro_entangled_com_x;
	// uint256 lro_entangled_com_y;
	var tmp64 [64]byte
	tmp64 = proof.LROEntangled.RawBytes()
	res = append(res, tmp64[:]...)

	// uint256 Z non entangled
	tmp64 = proof.Z.RawBytes()
	res = append(res, tmp64[:]...)

	// uint256 Z entangled
	tmp64 = proof.ZEntangled.RawBytes()
	res = append(res, tmp64[:]...)

	// H entangled
	tmp64 = proof.HEntangled.RawBytes()
	res = append(res, tmp64[:]...)

	// BSB commitments
	for i := 0; i < len(proof.BsbComEntangled); i++ {
		tmp64 = proof.BsbComEntangled[i].RawBytes()
		res = append(res, tmp64[:]...)
	}

	// at this stage we serialise the fflonk proof

	// claimed values of (in that order):
	// ql, qr, qm, qo, qkIncomplete, s1, s2, s3, qcp_i, l, r, o, z, h1, h2, h3, bsb_i at ζ
	// z at ωζ
	var tmp32 [32]byte
	for i := 0; i < len(proof.BatchOpeningProof.ClaimedValues[0]); i++ {
		tmp32 = proof.BatchOpeningProof.ClaimedValues[0][i][0].Bytes()
		res = append(res, tmp32[:]...)
	}
	tmp32 = proof.BatchOpeningProof.ClaimedValues[0][0][0].Bytes()
	res = append(res, tmp32[:]...)

	// shplonk.W
	tmp64 = proof.BatchOpeningProof.SOpeningProof.W.RawBytes()
	res = append(res, tmp64[:]...)

	// shplonk.WPrime
	tmp64 = proof.BatchOpeningProof.SOpeningProof.WPrime.RawBytes()
	res = append(res, tmp64[:]...)

	// shplonk.ClaimedValues
	for i := 0; i < len(proof.BatchOpeningProof.SOpeningProof.ClaimedValues[0]); i++ {
		tmp32 = proof.BatchOpeningProof.SOpeningProof.ClaimedValues[0][i].Bytes()
		res = append(res, tmp32[:]...)
	}
	tmp32 = proof.BatchOpeningProof.SOpeningProof.ClaimedValues[1][0].Bytes()
	res = append(res, tmp32[:]...)

	return res
}
