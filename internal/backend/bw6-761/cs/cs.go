// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package cs

import (
	"errors"
	"fmt"
	"math/big"

	"github.com/consensys/gnark/backend/hint"
	"github.com/consensys/gnark/internal/backend/compiled"

	"github.com/consensys/gnark-crypto/ecc/bw6-761/fr"
)

// ErrUnsatisfiedConstraint can be generated when solving a R1CS
var ErrUnsatisfiedConstraint = errors.New("constraint is not satisfied")

type hintFunction func(input []fr.Element) fr.Element

// solution represents elements needed to compute
// a solution to a R1CS or SparseR1CS
type solution struct {
	values, coefficients []fr.Element
	solved               []bool
	nbSolved             int
	mHintsFunctions      map[hint.ID]hintFunction
}

func newSolution(nbWires int, hintFunctions []hint.Function, coefficients []fr.Element) (solution, error) {
	s := solution{
		values:          make([]fr.Element, nbWires),
		coefficients:    coefficients,
		solved:          make([]bool, nbWires),
		mHintsFunctions: make(map[hint.ID]hintFunction, len(hintFunctions)+2),
	}

	s.mHintsFunctions = make(map[hint.ID]hintFunction, len(hintFunctions)+2)
	s.mHintsFunctions[hint.IsZero] = powModulusMinusOne
	s.mHintsFunctions[hint.IthBit] = ithBit

	for i := 0; i < len(hintFunctions); i++ {
		if _, ok := s.mHintsFunctions[hintFunctions[i].ID]; ok {
			return solution{}, fmt.Errorf("duplicate hint function with id %d", uint32(hintFunctions[i].ID))
		}
		f, ok := hintFunctions[i].F.(hintFunction)
		if !ok {
			return solution{}, fmt.Errorf("invalid hint function signature with id %d", uint32(hintFunctions[i].ID))
		}
		s.mHintsFunctions[hintFunctions[i].ID] = f
	}

	return s, nil
}

func (s *solution) set(id int, value fr.Element) {
	if s.solved[id] {
		panic("solving the same wire twice should never happen.")
	}
	s.values[id] = value
	s.solved[id] = true
	s.nbSolved++
}

func (s *solution) isValid() bool {
	return s.nbSolved == len(s.values)
}

// computeTerm computes coef*variable
func (s *solution) computeTerm(t compiled.Term) fr.Element {
	cID, vID, _ := t.Unpack()
	if cID != 0 && !s.solved[vID] {
		panic("computing a term with an unsolved wire")
	}
	switch cID {
	case compiled.CoeffIdZero:
		return fr.Element{}
	case compiled.CoeffIdOne:
		return s.values[vID]
	case compiled.CoeffIdTwo:
		var res fr.Element
		res.Double(&s.values[vID])
		return res
	case compiled.CoeffIdMinusOne:
		var res fr.Element
		res.Neg(&s.values[vID])
		return res
	default:
		var res fr.Element
		res.Mul(&s.coefficients[cID], &s.values[vID])
		return res
	}
}

// solveHint compute solution.values[vID] using provided solver hint
func (s *solution) solveHint(h compiled.Hint, vID int) error {
	// compute values for all inputs.
	inputs := make([]fr.Element, len(h.Inputs))

	for i := 0; i < len(h.Inputs); i++ {
		// input is a linear expression, we must compute the value
		for j := 0; j < len(h.Inputs[i]); j++ {
			ciID, viID, visibility := h.Inputs[i][j].Unpack()
			if visibility == compiled.Virtual {
				// we have a constant, just take the coefficient value
				inputs[i].Add(&inputs[i], &s.coefficients[ciID])
				continue
			}
			if !s.solved[viID] {
				return errors.New("expected wire to be instantiated while evaluating hint")
			}
			v := s.computeTerm(h.Inputs[i][j])
			inputs[i].Add(&inputs[i], &v)
		}
	}

	f, ok := s.mHintsFunctions[h.ID]
	if !ok {
		return errors.New("missing hint function")
	}
	s.set(vID, f(inputs))
	return nil
}

// default hint functions

// powModulusMinusOne expects len(inputs) == 1
// inputs[0] == a
// returns m = a^(modulus-1) - 1
func powModulusMinusOne(inputs []fr.Element) (v fr.Element) {
	if len(inputs) != 1 {
		panic("expected one input")
	}
	var eOne big.Int
	eOne.SetUint64(1)
	eOne.Sub(fr.Modulus(), &eOne)
	v.Exp(inputs[0], &eOne)
	one := fr.One()
	v.Sub(&one, &v)
	return v
}

// ithBit expects len(inputs) == 2
// inputs[0] == a
// inputs[1] == n
// returns bit number n of a
func ithBit(inputs []fr.Element) (v fr.Element) {
	if len(inputs) != 2 {
		panic("expected 2 inputs; inputs[0] == value, inputs[1] == bit position")
	}
	// TODO @gbotrel this is very inneficient; it adds ~256*2 multiplications to extract all bits of a value.
	inputs[0].FromMont()
	inputs[1].FromMont()
	if !inputs[1].IsUint64() {
		panic("expected bit position to fit on one word")
	}
	v.SetUint64(inputs[0].Bit(inputs[1][0]))

	return v
}
