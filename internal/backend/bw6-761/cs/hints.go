// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package cs

import (
	"math/big"

	"github.com/consensys/gnark-crypto/ecc/bw6-761/fr"
)

// hintFunction signature hints functions must match
type hintFunction func(input []fr.Element) fr.Element

// powModulusMinusOne expects len(inputs) == 1
// inputs[0] == a
// returns m = a^(modulus-1) - 1
func powModulusMinusOne(inputs []fr.Element) (v fr.Element) {
	if len(inputs) != 1 {
		panic("expected one input")
	}
	var eOne big.Int
	eOne.SetUint64(1)
	eOne.Sub(fr.Modulus(), &eOne)
	v.Exp(inputs[0], &eOne)
	one := fr.One()
	v.Sub(&one, &v)
	return v
}

// ithBit expects len(inputs) == 2
// inputs[0] == a
// inputs[1] == n
// returns bit number n of a
func ithBit(inputs []fr.Element) (v fr.Element) {
	if len(inputs) != 2 {
		panic("expected 2 inputs; inputs[0] == value, inputs[1] == bit position")
	}
	// TODO @gbotrel this is very inneficient; it adds ~256*2 multiplications to extract all bits of a value.
	inputs[0].FromMont()
	inputs[1].FromMont()
	if !inputs[1].IsUint64() {
		panic("expected bit position to fit on one word")
	}
	v.SetUint64(inputs[0].Bit(inputs[1][0]))

	return v
}
