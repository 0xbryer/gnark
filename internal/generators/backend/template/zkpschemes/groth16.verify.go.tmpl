import (
	{{ template "import_fr" . }}
	{{ template "import_curve" . }}
	"github.com/consensys/gnark/backend"
	"errors"
)

var errPairingCheckFailed = errors.New("pairing doesn't match")
var errCorrectSubgroupCheckFailed = errors.New("points in the proof are not in the correct subgroup")

// Verify verifies a proof
func Verify(proof *Proof, vk *VerifyingKey, inputs map[string]interface{}) error {

	// check that the points in the proof are in the correct subgroup
	if !proof.isValid() {
		return errCorrectSubgroupCheckFailed
	}

	var doubleML curve.GT
	var err error
	ch := make(chan bool, 1)
	go func() {
		doubleML, err = curve.MillerLoop([]curve.G1Affine{proof.Krs, proof.Ar}, []curve.G2Affine{vk.G2.DeltaNeg, proof.Bs})
		ch <- true
	}()
	if err != nil {
		return err
	}

	var kSum curve.G1Jac
	kInputs, err := ParsePublicInput(vk.PublicInputs, inputs)
	if err != nil {
		return err
	}
	kSum.MultiExp(vk.G1.K, kInputs)

	// e(Σx.[Kvk(t)]1, -[γ]2)
	var kSumAff curve.G1Affine
	kSumAff.FromJacobian(&kSum)

	right, err := curve.MillerLoop([]curve.G1Affine{kSumAff}, []curve.G2Affine{vk.G2.GammaNeg})
	if err != nil {
		return err
	}

	<-ch
	right = curve.FinalExponentiation(right.Mul(&right, &doubleML))

	if !vk.E.Equal(&right) {
		return errPairingCheckFailed
	}
	return nil
}

// ParsePublicInput return the ordered public input values
// in regular form (used as scalars for multi exponentiation).
// The function is public because it's needed for the recursive snark.
func ParsePublicInput(expectedNames []string, input map[string]interface{}) ([]fr.Element, error) {
	toReturn := make([]fr.Element, len(expectedNames))

	for i := 0; i < len(expectedNames); i++ {
		if expectedNames[i] == backend.OneWire {
			// ONE_WIRE is a reserved name, it should not be set by the user
			toReturn[i].SetOne()
			toReturn[i].FromMont()
		} else {
			if val, ok := input[expectedNames[i]]; ok {
				toReturn[i].SetInterface(val)
				toReturn[i].FromMont() 
			} else {
				return nil, backend.ErrInputNotSet
			}
		}
	}

	return toReturn, nil
}
