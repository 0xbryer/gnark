import (
 	{{ template "import_curve" . }}
	{{/* {{ template "import_fr" . }} */}}
	"io" 
)


 {{/* // WriteTo writes binary encoding of ProofRaw to w 
func (proof *ProofRaw) WriteTo(w io.Writer) (int64, error) {
	enc := curve.NewEncoder(w)

	if err := enc.Encode(proof.LROZH[:]); err != nil {
		return enc.BytesWritten(), err
	}
	if err := enc.Encode(proof.ZShift); err != nil {
		return enc.BytesWritten(), err
	}

	var n int64
	for i:=0; i < len(proof.CommitmentsLROZH); i++ {
		n2, err := w.Write(proof.CommitmentsLROZH[i].Marshal())
		n += int64(n2)
		if err != nil {
			return enc.BytesWritten() + n, err
		}
	}

	n2, err := w.Write(proof.BatchOpenings.Marshal())
	n += int64(n2)
	if err != nil {
		return enc.BytesWritten() + n, err
	}

	n2, err = w.Write(proof.OpeningZShift.Marshal())
	n += int64(n2)
	if err != nil {
		return enc.BytesWritten() + n, err
	}
	
	return n + enc.BytesWritten(), nil
}

// ReadFrom reads binary representation of Proof from r
func (proof *ProofRaw) ReadFrom(r io.Reader) (int64, error) {
	dec := curve.NewDecoder(r)
	toDecode := []interface{}{
		(*[]fr.Element)(&proof.LROZH[:]),
		(*[]fr.Element)(&p.ZShift),
	}

	for _, v := range toDecode {
		if err := dec.Decode(v); err != nil {
			return dec.BytesRead(), err
		}
	}

	

} */}}


// WriteTo writes binary encoding of VerifyingKey to w
func (vk *VerifyingKey) WriteTo(w io.Writer) (n int64, err error) {
	enc := curve.NewEncoder(w)

	toEncode := []interface{} {
		vk.Size, 
		vk.SizeInv,
		vk.Generator,
		vk.Shifter[0],
		vk.Shifter[1],
		vk.S[0],
		vk.S[1],
		vk.S[2],
		vk.Ql,
		vk.Qr,
		vk.Qm,
		vk.Qo,
		vk.Qk,
	}

	for _, v := range toEncode {
		if err := enc.Encode(v); err != nil {
			return enc.BytesWritten(), err
		}
	}

	
	return enc.BytesWritten(), nil
}

// ReadFrom reads from binary representation in r into VerifyingKey
func (vk *VerifyingKey) ReadFrom(r io.Reader) (int64, error) {
	dec := curve.NewDecoder(r)
	toDecode := []interface{}{
		&vk.Size, 
		&vk.SizeInv,
		&vk.Generator,
		&vk.Shifter[0],
		&vk.Shifter[1],
		&vk.S[0],
		&vk.S[1],
		&vk.S[2],
		&vk.Ql,
		&vk.Qr,
		&vk.Qm,
		&vk.Qo,
		&vk.Qk,
	}

	for _, v := range toDecode {
		if err := dec.Decode(v); err != nil {
			return dec.BytesRead(), err
		}
	}

	return dec.BytesRead(), nil
} 