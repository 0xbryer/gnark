package gpoint

// Src is the aggregated source code
var Src []string

// Tst is the aggregated test code
var Tst []string

func init() {
	Src = []string{
		base,
		add,
		addMixed,
		double,
		scalarMul,
		multiExp,
		windowedMultiExp,
	}

	Tst = []string{
		tests,
		benchmarks,
	}
}

const base = `
// Code generated by internal/gpoint DO NOT EDIT 

// Most algos for points operations are taken from http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html

package {{.PackageName}}

import (
	{{if eq .CType "fp.Element"}}
		"github.com/consensys/gnark/ecc/{{.PackageName}}/fp"
	{{end}}
	"github.com/consensys/gnark/ecc/{{.PackageName}}/fr"
	"github.com/consensys/gnark/internal/pool"
	"github.com/consensys/gnark/internal/debug"
	"sync"
)

// {{.Name}}Jac is a point with {{.CType}} coordinates
type {{.Name}}Jac struct {
	X, Y, Z {{.CType}}
}

// {{.Name}}Affine point in affine coordinates
type {{.Name}}Affine struct {
	X, Y {{.CType}}
}

// Set set p to the provided point
func (p *{{.Name}}Jac) Set(a *{{.Name}}Jac) *{{.Name}}Jac {
	p.X.Set(&a.X)
	p.Y.Set(&a.Y)
	p.Z.Set(&a.Z)
	return p
}

// Equal tests if two points (in Jacobian coordinates) are equal
func (p *{{.Name}}Jac) Equal(a *{{.Name}}Jac) bool {

	if p.Z.IsZero() && a.Z.IsZero() {
		return true
	}
	_p := {{.Name}}Affine{}
	p.ToAffineFromJac(&_p)

	_a := {{.Name}}Affine{}
	a.ToAffineFromJac(&_a)

	return _p.X.Equal(&_a.X) && _p.Y.Equal(&_a.Y)
}

// Equal tests if two points (in Affine coordinates) are equal
func (p *{{ .Name}}Affine) Equal(a *{{ .Name}}Affine) bool {
	return p.X.Equal(&a.X) && p.Y.Equal(&a.Y)
}

// Clone returns a copy of self
func (p *{{.Name}}Jac) Clone() *{{.Name}}Jac {
	return &{{.Name}}Jac{
		p.X, p.Y, p.Z,
	}
}


// Neg computes -G
func (p *{{.Name}}Jac) Neg(a *{{.Name}}Jac) *{{.Name}}Jac {
	p.Set(a)
	p.Y.Neg(&a.Y)
	return p
}

// Neg computes -G
func (p *{{.Name}}Affine) Neg(a *{{.Name}}Affine) *{{.Name}}Affine {
	p.X.Set(&a.X)
	p.Y.Neg(&a.Y)
	return p
}

// Sub substracts two points on the curve
func (p *{{.Name}}Jac) Sub(curve *Curve, a {{.Name}}Jac) *{{.Name}}Jac {
	a.Y.Neg(&a.Y)
	p.Add(curve, &a)
	return p
}

// ToAffineFromJac rescale a point in Jacobian coord in z=1 plane
// WARNING super slow function (due to the division)
func (p *{{.Name}}Jac) ToAffineFromJac(res *{{.Name}}Affine) *{{.Name}}Affine {

	var bufs [3]{{.CType}}

	if p.Z.IsZero() {
		res.X.SetZero()
		res.Y.SetZero()
		return res
	}

	bufs[0].Inverse(&p.Z)
	bufs[2].Square(&bufs[0])
	bufs[1].Mul(&bufs[2], &bufs[0])

	res.Y.Mul(&p.Y, &bufs[1])
	res.X.Mul(&p.X, &bufs[2])

	return res
}

// ToProjFromJac converts a point from Jacobian to projective coordinates
func (p *{{.Name}}Jac) ToProjFromJac() *{{.Name}}Jac {
	// memalloc
	var buf {{.CType}}
	buf.Square(&p.Z)

	p.X.Mul(&p.X, &p.Z)
	p.Z.Mul(&p.Z, &buf)

	return p
}

func (p *{{.Name}}Jac) String(curve *Curve) string {
	if p.Z.IsZero() {
		return "O"
	}
	_p := {{.Name}}Affine{}
	p.ToAffineFromJac(&_p)
	_p.X.FromMont()
	_p.Y.FromMont()
	return "E([" + _p.X.String() + "," + _p.Y.String() + "]),"
}

// ToJacobian sets Q = p, Q in Jacboian, p in affine
func (p *{{ .Name}}Affine) ToJacobian(Q *{{ .Name}}Jac) *{{ .Name}}Jac {
	if p.X.IsZero() && p.Y.IsZero() {
		Q.Z.SetZero()
		Q.X.SetOne()
		Q.Y.SetOne()
		return Q
	}
	Q.Z.SetOne()
	Q.X.Set(&p.X)
	Q.Y.Set(&p.Y)
	return Q
}

func (p *{{.Name}}Affine) String(curve *Curve) string {
	var x, y {{.CType}}
	x.Set(&p.X)
	y.Set(&p.Y)
	return "E([" + x.FromMont().String() + "," + y.FromMont().String() + "]),"
}

// IsInfinity checks if the point is infinity (in affine, it's encoded as (0,0))
func (p *{{.Name}}Affine) IsInfinity() bool {
	return p.X.IsZero() && p.Y.IsZero()
}
`
