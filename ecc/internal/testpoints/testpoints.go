package testpoints

import (
	"bytes"
	"os"
	"os/exec"
	"strings"
)

type MethodType int

const (
	Binary MethodType = iota
	Unary
	Custom
)

type MethodTypeMap map[string]MethodType

// MethodTypes for named constants inside templates
var MethodTypes = MethodTypeMap{
	"Binary": Binary,
	"Unary":  Unary,
	"Custom": Custom,
}

type Method struct {
	Name string
	Type MethodType
}

type Point []string
type PointTuple []Point

type TestPoint struct {
	In  PointTuple // len(In) = number of arguments, eg 1 or 2
	Out []Point    // output of each method
}

type InputSource interface {
	FixedInputs() []PointTuple
	RandomInput() PointTuple
}

func GenerateTestOutputs(in InputSource, sagePath string, sagePrefixArgs ...string) []TestPoint {
	var args, outputs []string

	const numRandomInputs = 3

	// prepare input points
	inputs := in.FixedInputs()
	result := make([]TestPoint, len(inputs)+numRandomInputs)
	for i := range inputs {
		result[i].In = inputs[i]
	}
	for i := 0; i < numRandomInputs; i++ {
		result[len(inputs)+i].In = in.RandomInput()
	}

	// prepare input args for sage
	args = sagePrefixArgs
	for i := range result {
		for j := range result[i].In {
			args = append(args, result[i].In[j][:]...)
		}
	}

	// get outputs from sage
	var output bytes.Buffer
	cmd := exec.Command(sagePath, args...)
	cmd.Stdout = &output
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		panic(err)
	}
	outputs = strings.Split(output.String(), "\n")

	// uncomment for debugging
	// for i := range outputs {
	// 	fmt.Printf("\"%s\",\n", outputs[i])
	// }

	// uncomment to hard-code sage output
	// outputs = []string{"0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0"}

	// fill result outputs
	for i := range result {
		for j := range result[i].Out {
			for k := range result[i].Out[j] {
				index := i
				index = index*len(result[i].Out) + j
				index = index*len(result[i].Out[j]) + k
				result[i].Out[j][k] = outputs[index]
			}
		}
	}

	return result
}

const TestPoints = `
// Code generated by internal/tower DO NOT EDIT 
package {{.PackageName}}

{{ define "printTestPoint" }}
	{{- range $coord := .Coords -}}
		"{{$coord}}",
	{{- end -}}
{{ end }}

func init() {
	{{if ne (len .TestPoints) 0}}
		{{.Name}}TestPoints = make([]{{.Name}}TestPoint, {{len .TestPoints}})
	{{end}}
	{{range $i, $point := .TestPoints}}
		{{- range $j, $in := $point.In }}
			{{$.Name}}TestPoints[{{$i}}].in[{{$j}}].SetString({{ template "printTestPoint" dict "Coords" (index $point.In $j) }})
		{{- end }}
		{{- range $j, $out := $point.Out }}
			{{$.Name}}TestPoints[{{$i}}].out[{{$j}}].SetString({{ template "printTestPoint" dict "Coords" (index $point.Out $j) }})
		{{- end }}
	{{end}}

	{{if ne (len .TestPoints) 0}}
		// benchmark inputs should be randomly generated,
		// so use the final test point
		{{.Name}}BenchIn1.Set(&{{.Name}}TestPoints[len({{.Name}}TestPoints)-1].in[0])
		{{.Name}}BenchIn2.Set(&{{.Name}}TestPoints[len({{.Name}}TestPoints)-1].in[1])
	{{- end }}
}
`
