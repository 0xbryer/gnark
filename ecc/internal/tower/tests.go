package tower

const Tests = `
// Code generated by internal/tower DO NOT EDIT 
package {{.PackageName}}

import (
	"reflect"
	"testing"
)

type {{.Name}}TestPoint struct {
	in [2]{{.Name}}
	out [{{len .Methods}}]{{.Name}}
	{{/* {{- range $m := .Methods }}
		{{$m.Name}} {{$.Name}}
	{{- end }} */}}
}

var {{.Name}}TestPoints []{{.Name}}TestPoint

// TODO this method is the same everywhere. move it someplace central and call it "compare"
func {{.Name}}compare(t *testing.T, got, want interface{}) {
	if !reflect.DeepEqual(got, want) {
		t.Fatal("\nexpect:\t", want, "\ngot:\t", got)
	}
}

func {{.Name}}check(t *testing.T, f func(*{{.Name}}, *{{.Name}}, *{{.Name}}) *{{.Name}}, m int) {

	if len({{.Name}}TestPoints) < 1 {
		t.Log("no tests to run")
	}

	for i := range {{.Name}}TestPoints {
		var receiver {{.Name}}
		var out *{{.Name}}
		var inCopies [len({{.Name}}TestPoints[i].in)]{{.Name}}

		for j := range inCopies {
			inCopies[j].Set(&{{.Name}}TestPoints[i].in[j])
		}

		// receiver, return value both set to result
		out = f(&receiver, &inCopies[0], &inCopies[1])

		{{.Name}}compare(t, receiver, {{.Name}}TestPoints[i].out[m]) // receiver correct
		{{.Name}}compare(t, *out, {{.Name}}TestPoints[i].out[m])     // return value correct
		for j := range inCopies {
			{{.Name}}compare(t, inCopies[j], {{.Name}}TestPoints[i].in[j]) // inputs unchanged
		}

		// receiver == one of the inputs
		for j := range inCopies {
			out = f(&inCopies[j], &inCopies[0], &inCopies[1])

			{{.Name}}compare(t, inCopies[j], {{.Name}}TestPoints[i].out[m]) // receiver correct
			{{.Name}}compare(t, *out, {{.Name}}TestPoints[i].out[m])        // return value correct
			for k := range inCopies {
				if k == j {
					continue
				}
				{{.Name}}compare(t, inCopies[k], {{.Name}}TestPoints[i].in[k]) // other inputs unchanged
			}
			inCopies[j].Set(&{{.Name}}TestPoints[i].in[j]) // reset input for next tests
		}
	}
}

//--------------------//
//     tests		  //
//--------------------//

{{ range $i, $m := .Methods }}

	func Test{{capitalize $.Name}}{{$m.Name}}(t *testing.T) {
		{{$.Name}}check(t, (*{{$.Name}}).{{$m.Name}}

		{{- if ne $m.Type $.MethodTypes.Binary -}}
			Binary
		{{- end -}}

		, {{$i}})
	}
	
{{ end }}

//--------------------//
//     benches		  //
//--------------------//

var {{.Name}}BenchIn1, {{.Name}}BenchIn2, {{.Name}}BenchOut {{.Name}}

{{ range $i, $m := .Methods }}

	func Benchmark{{capitalize $.Name}}{{$m.Name}}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			{{$.Name}}BenchOut.{{$m.Name}}

			{{- if ne $m.Type $.MethodTypes.Binary -}}
				Binary
			{{- end -}}
		
			(&{{$.Name}}BenchIn1, &{{$.Name}}BenchIn2)
		}
	}

{{ end }}

//-------------------------------------//
// unary helpers for {{.Name}} methods
//-------------------------------------//

{{ range $i, $m := .Methods }}

	{{- if eq $m.Type $.MethodTypes.Unary }}
		// {{$m.Name}}Binary a binary wrapper for {{$m.Name}}
		func (z *{{$.Name}}) {{$m.Name}}Binary(x, y *{{$.Name}}) *{{$.Name}} {
			return z.{{$m.Name}}(x)
		}
	{{ end }}
	
{{ end }}
`
