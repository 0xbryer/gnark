package fields_bls12381

// TODO: correct addchain to BLS12-381 seed

func (e Ext12) Expt(x *E12) *E12 {
	// Expt computation is derived from the addition chain:
	//
	//	_10     = 2*1
	//	_100    = 2*_10
	//	_1000   = 2*_100
	//	_10000  = 2*_1000
	//	_10001  = 1 + _10000
	//	_10011  = _10 + _10001
	//	_10100  = 1 + _10011
	//	_11001  = _1000 + _10001
	//	_100010 = 2*_10001
	//	_100111 = _10011 + _10100
	//	_101001 = _10 + _100111
	//	i27     = (_100010 << 6 + _100 + _11001) << 7 + _11001
	//	i44     = (i27 << 8 + _101001 + _10) << 6 + _10001
	//	i70     = ((i44 << 8 + _101001) << 6 + _101001) << 10
	//	return    (_100111 + i70) << 6 + _101001 + _1000
	//
	// Operations: 62 squares 17 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	t3 := e.CyclotomicSquare(x)
	t5 := e.CyclotomicSquare(t3)
	result := e.CyclotomicSquare(t5)
	t0 := e.CyclotomicSquare(result)
	t2 := e.Mul(x, t0)
	t0 = e.Mul(t3, t2)
	t1 := e.Mul(x, t0)
	t4 := e.Mul(result, t2)
	t6 := e.CyclotomicSquare(t2)
	t1 = e.Mul(t0, t1)
	t0 = e.Mul(t3, t1)
	t6 = e.NCycloSquareCompressed(t6, 6)
	t6 = e.DecompressKarabina(t6)
	t5 = e.Mul(t5, t6)
	t5 = e.Mul(t4, t5)
	t5 = e.NCycloSquareCompressed(t5, 7)
	t5 = e.DecompressKarabina(t5)
	t4 = e.Mul(t4, t5)
	t4 = e.NCycloSquareCompressed(t4, 8)
	t4 = e.DecompressKarabina(t4)
	t4 = e.Mul(t0, t4)
	t3 = e.Mul(t3, t4)
	t3 = e.NCycloSquareCompressed(t3, 6)
	t3 = e.DecompressKarabina(t3)
	t2 = e.Mul(t2, t3)
	t2 = e.NCycloSquareCompressed(t2, 8)
	t2 = e.DecompressKarabina(t2)
	t2 = e.Mul(t0, t2)
	t2 = e.NCycloSquareCompressed(t2, 6)
	t2 = e.DecompressKarabina(t2)
	t2 = e.Mul(t0, t2)
	t2 = e.NCycloSquareCompressed(t2, 10)
	t2 = e.DecompressKarabina(t2)
	t1 = e.Mul(t1, t2)
	t1 = e.NCycloSquareCompressed(t1, 6)
	t1 = e.DecompressKarabina(t1)
	t0 = e.Mul(t0, t1)
	z := e.Mul(result, t0)
	return z
}

// MulBy014 multiplies z by an E12 sparse element of the form
//
//	E12{
//		C0: E6{B0: 1, B1: c1, B2: 0},
//		C1: E6{B0: 0, B1: c4, B2: 0},
//	}
//
// TODO : correct MulByO14 and not 034
func (e *Ext12) MulBy014(z *E12, c1, c4 *E2) *E12 {

	a := z.C0
	b := z.C1

	b = *e.MulBy01(&b, c1, c4)
	one := e.Ext2.One()

	c1 = e.Ext2.Add(one, c1)
	d := e.Ext6.Add(&z.C0, &z.C1)
	d = e.MulBy01(d, c1, c4)

	zC1 := e.Ext6.Add(&a, &b)
	zC1 = e.Ext6.Neg(zC1)
	zC1 = e.Ext6.Add(zC1, d)
	zC0 := e.Ext6.MulByNonResidue(&b)
	zC0 = e.Ext6.Add(zC0, &a)

	return &E12{
		C0: *zC0,
		C1: *zC1,
	}
}
