package fields_bls12381

// ExptHalf set z to x^(t/2) in E12 and return z
// const t/2 uint64 = 7566188111470821376 // negative
func (e Ext12) ExptHalf(x *E12) *E12 {
	// FixedExp computation is derived from the addition chain:
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_1100    = _11 << 2
	//	_1101    = 1 + _1100
	//	_1101000 = _1101 << 3
	//	_1101001 = 1 + _1101000
	//	return     ((_1101001 << 9 + 1) << 32 + 1) << 15
	//
	// Operations: 62 squares 5 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Step 1: z = x^0x2
	z := e.Square(x)

	// Step 2: z = x^0x3
	z = e.Mul(x, z)

	z = e.CyclotomicSquare(z)
	z = e.CyclotomicSquare(z)

	// Step 5: z = x^0xd
	z = e.Mul(x, z)

	// Step 8: z = x^0x68
	// TODO: for 3 squares in a row SQR12345 variant of Karabina's cyclotomic
	// square (paragraph 5.6) is preferred.
	// NCycloSquareCompressed() implements SQR2345 variant.
	z = e.NCycloSquareCompressed(z, 3)
	z = e.DecompressKarabina(z)

	// Step 9: z = x^0x69
	z = e.Mul(x, z)

	// Step 18: z = x^0xd200
	z = e.NCycloSquareCompressed(z, 9)
	z = e.DecompressKarabina(z)

	// Step 19: z = x^0xd201
	z = e.Mul(x, z)

	// Step 51: z = x^0xd20100000000
	z = e.NCycloSquareCompressed(z, 32)
	z = e.DecompressKarabina(z)

	// Step 52: z = x^0xd20100000001
	z = e.Mul(x, z)

	// Step 67: z = x^0x6900800000008000
	z = e.NCycloSquareCompressed(z, 15)
	z = e.DecompressKarabina(z)

	z = e.Conjugate(z) // because tAbsVal is negative

	return z
}

// Expt set z to xáµ— in E12 and return z
// const t uint64 = 15132376222941642752 // negative
func (e Ext12) Expt(x *E12) *E12 {
	z := e.ExptHalf(x)
	z = e.CyclotomicSquare(z)
	return z
}

// MulBy014 multiplies z by an E12 sparse element of the form
//
//	E12{
//		C0: E6{B0: c0, B1: c1, B2: 0},
//		C1: E6{B0: 0, B1: 1, B2: 0},
//	}
func (e *Ext12) MulBy014(z *E12, c0, c1 *E2) *E12 {

	a := z.C0
	a = *e.MulBy01(&a, c0, c1)

	var b E6
	// Mul by E6{0, 1, 0}
	b.B0 = *e.Ext2.MulByNonResidue(&z.C1.B2)
	b.B2 = z.C1.B1
	b.B1 = z.C1.B0

	one := e.Ext2.One()
	d := e.Ext2.Add(c1, one)

	zC1 := e.Ext6.Add(&z.C1, &z.C0)
	zC1 = e.Ext6.MulBy01(zC1, c0, d)
	zC1 = e.Ext6.Sub(zC1, &a)
	zC1 = e.Ext6.Sub(zC1, &b)
	zC0 := e.Ext6.MulByNonResidue(&b)
	zC0 = e.Ext6.Add(zC0, &a)

	return &E12{
		C0: *zC0,
		C1: *zC1,
	}
}

//	multiplies two E12 sparse element of the form:
//
//	E12{
//		C0: E6{B0: c0, B1: c1, B2: 0},
//		C1: E6{B0: 0, B1: 1, B2: 0},
//	}
//
// and
//
//	E12{
//		C0: E6{B0: d0, B1: d1, B2: 0},
//		C1: E6{B0: 0, B1: 1, B2: 0},
//	}
func (e Ext12) Mul014By014(d0, d1, c0, c1 *E2) *[5]E2 {
	one := e.Ext2.One()
	x0 := e.Ext2.Mul(c0, d0)
	x1 := e.Ext2.Mul(c1, d1)
	tmp := e.Ext2.Add(c0, one)
	x04 := e.Ext2.Add(d0, one)
	x04 = e.Ext2.Mul(x04, tmp)
	x04 = e.Ext2.Sub(x04, x0)
	x04 = e.Ext2.Sub(x04, one)
	tmp = e.Ext2.Add(c0, c1)
	x01 := e.Ext2.Add(d0, d1)
	x01 = e.Ext2.Mul(x01, tmp)
	x01 = e.Ext2.Sub(x01, x0)
	x01 = e.Ext2.Sub(x01, x1)
	tmp = e.Ext2.Add(c1, one)
	x14 := e.Ext2.Add(d1, one)
	x14 = e.Ext2.Mul(x14, tmp)
	x14 = e.Ext2.Sub(x14, x1)
	x14 = e.Ext2.Sub(x14, one)

	zC0B0 := e.Ext2.NonResidue()
	zC0B0 = e.Ext2.Add(zC0B0, x0)

	return &[5]E2{*zC0B0, *x01, *x1, *x04, *x14}
}

// MulBy01245 multiplies z by an E12 sparse element of the form
//
//	E12{
//		C0: E6{B0: c0, B1: c1, B2: c2},
//		C1: E6{B0: 0, B1: c4, B2: c5},
//	}
func (e *Ext12) MulBy01245(z *E12, x *[5]E2) *E12 {
	c0 := &E6{B0: x[0], B1: x[1], B2: x[2]}
	c1 := &E6{B0: *e.Ext2.Zero(), B1: x[3], B2: x[4]}
	a := e.Ext6.Add(&z.C0, &z.C1)
	b := e.Ext6.Add(c0, c1)
	a = e.Ext6.Mul(a, b)
	b = e.Ext6.Mul(&z.C0, c0)
	c := e.Ext6.MulBy12(&z.C1, &x[3], &x[4])
	z1 := e.Ext6.Sub(a, b)
	z1 = e.Ext6.Sub(z1, c)
	z0 := e.Ext6.MulByNonResidue(c)
	z0 = e.Ext6.Add(z0, b)
	return &E12{
		C0: *z0,
		C1: *z1,
	}
}
