/*
Copyright © 2020 ConsenSys

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package poseidon

import (
	"math/big"

	"github.com/consensys/gnark/frontend"
)

// Poseidon contains the params of the Poseidon hash function
type Poseidon struct {
	data []frontend.Variable // state storage. data is updated when Write() is called. Sum sums the data.
	api  frontend.API        // underlying constraint system
}

// NewPoseidon returns a Poseidon instance, than can be used in a gnark circuit
func NewPoseidon(api frontend.API) Poseidon {
	return Poseidon{
		api:  api,
		data: []frontend.Variable{},
	}
}

// Write adds more data to the running hash.
func (h *Poseidon) Write(data ...frontend.Variable) {
	h.data = append(h.data, data...)
}

// Reset resets the Hash to its initial state.
func (h *Poseidon) Reset() {
	h.data = nil
}

// Sum hashes in r1cs or scs form.
func (h *Poseidon) Sum() frontend.Variable {
	nInputs := len(h.data)
	// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
	// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
	// And rounded up to nearest integer that divides by t
	//
	// TODO @yelhousni: adapt and generify to other curves
	nRoundsPC := [16]int{56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68}
	t := nInputs + 1
	nRoundsF := 8
	nRoundsP := nRoundsPC[t-2]
	c := getConstant(C, t)
	s := getConstant(S, t)
	m := getConstant(M, t)
	p := getConstant(P, t)

	state := make([]frontend.Variable, t)
	for j := 0; j < t; j++ {
		if j == 0 {
			state[0] = 0
		} else {
			state[j] = h.data[j-1]
		}
	}
	state = h.arc(state, c, 0)

	for r := 0; r < nRoundsF/2-1; r++ {
		for j := 0; j < t; j++ {
			state[j] = h.pow5(state[j])
		}
		state = h.arc(state, c, (r+1)*t)
		state = h.mix(state, m)
	}

	for j := 0; j < t; j++ {
		state[j] = h.pow5(state[j])
	}
	state = h.arc(state, c, nRoundsF/2*t)
	state = h.mix(state, p)

	for r := 0; r < nRoundsP; r++ {

		state[0] = h.pow5(state[0])

		state[0] = h.api.Add(state[0], c[(nRoundsF/2+1)*t+r])
		newState0 := frontend.Variable(0)
		for j := 0; j < len(state); j++ {
			mul := h.api.Mul(s[(t*2-1)*r+j], state[j])
			newState0 = h.api.Add(newState0, mul)
		}

		for k := 1; k < t; k++ {
			state[k] = h.api.Add(state[k], h.api.Mul(state[0], s[(t*2-1)*r+t+k-1]))
		}
		state[0] = newState0
	}

	for r := 0; r < nRoundsF/2-1; r++ {
		for j := 0; j < t; j++ {
			state[j] = h.pow5(state[j])
		}
		state = h.arc(state, c, (nRoundsF/2+1)*t+nRoundsP+r*t)
		state = h.mix(state, m)
	}

	for j := 0; j < t; j++ {
		state[j] = h.pow5(state[j])
	}

	out := h.mixLast(state, m, 0)
	h.data = []frontend.Variable{}
	return out
}

// pow5 applies the s-box as an α-power where α=5
func (h *Poseidon) pow5(in frontend.Variable) frontend.Variable {
	r := h.api.Mul(in, in)
	r = h.api.Mul(r, r)
	return h.api.Mul(r, in)
}

// arc adds the constant rounds keys
func (h *Poseidon) arc(in []frontend.Variable, c []*big.Int, r int) []frontend.Variable {
	out := make([]frontend.Variable, len(in))
	for i, v := range in {
		out[i] = h.api.Add(v, c[i+r])
	}
	return out
}

// mix mulitplies by the constant MDS matrix
func (h *Poseidon) mix(in []frontend.Variable, m [][]*big.Int) []frontend.Variable {
	t := len(in)
	out := make([]frontend.Variable, t)
	for i := 0; i < t; i++ {
		lc := frontend.Variable(0)
		for j := 0; j < t; j++ {
			lc = h.api.Add(lc, h.api.Mul(m[j][i], in[j]))
		}
		out[i] = lc
	}
	return out
}

func (h *Poseidon) mixLast(in []frontend.Variable, m [][]*big.Int, s int) frontend.Variable {
	t := len(in)
	out := frontend.Variable(0)
	for j := 0; j < t; j++ {
		out = h.api.Add(out, h.api.Mul(m[j][s], in[j]))
	}
	return out
}
